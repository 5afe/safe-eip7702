{
  "address": "0x2204DcA7d254897ae6d815D2189032db87F50Bba",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "modules",
          "type": "address[]"
        }
      ],
      "name": "enableModules",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "args": [],
  "numDeployments": 2,
  "solcInputHash": "1080ae6c3580d5deeb89e34c12e153e9",
  "metadata": "{\"compiler\":{\"version\":\"0.8.27+commit.40a35a09\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"modules\",\"type\":\"address[]\"}],\"name\":\"enableModules\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"custom:security-contact\":\"bounty@safe.global\",\"details\":\"The Safe `setup` function accepts `to` and `data` parameters for a delegate call during initialization. This      contract can be specified as the `to` with `data` ABI encoding the `enableModules` call so that a Safe is      created with the specified modules. In particular, this allows a ERC-4337 compatible Safe to be created as part      of a ERC-4337 user operation with the `Safe4337Module` enabled right away.\",\"kind\":\"dev\",\"methods\":{\"enableModules(address[])\":{\"details\":\"This call will only work if used from a Safe via delegatecall. It is intended to be used as part of the      Safe `setup`, allowing Safes to be created with an initial set of enabled modules.\",\"params\":{\"modules\":\"The modules to enable.\"}}},\"title\":\"SafeModuleSetup - A utility contract for setting up a Safe with modules.\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"enableModules(address[])\":{\"notice\":\"Enable the specified Safe modules.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/SafeModuleSetup.sol\":\"SafeModuleSetup\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":10000000},\"remappings\":[]},\"sources\":{\"@safe-global/safe-smart-account/contracts/interfaces/IFallbackManager.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\n\\n/**\\n * @title IFallbackManager - A contract interface managing fallback calls made to this contract.\\n * @author @safe-global/safe-protocol\\n */\\ninterface IFallbackManager {\\n    event ChangedFallbackHandler(address indexed handler);\\n\\n    /**\\n     * @notice Set Fallback Handler to `handler` for the Safe.\\n     * @dev Only fallback calls without value and with data will be forwarded.\\n     *      This can only be done via a Safe transaction.\\n     *      Cannot be set to the Safe itself.\\n     * @param handler contract to handle fallback calls.\\n     */\\n    function setFallbackHandler(address handler) external;\\n}\\n\",\"keccak256\":\"0x132930e9dbd31bcf89269fc2399cecf0f2d0366408a1ea8292e6249b47010182\",\"license\":\"LGPL-3.0-only\"},\"@safe-global/safe-smart-account/contracts/interfaces/IGuardManager.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\n/* solhint-disable one-contract-per-file */\\npragma solidity >=0.7.0 <0.9.0;\\n\\n/**\\n * @title IGuardManager - A contract interface managing transaction guards which perform pre and post-checks on Safe transactions.\\n * @author @safe-global/safe-protocol\\n */\\ninterface IGuardManager {\\n    event ChangedGuard(address indexed guard);\\n\\n    /**\\n     * @dev Set a guard that checks transactions before execution\\n     *      This can only be done via a Safe transaction.\\n     *      \\u26a0\\ufe0f IMPORTANT: Since a guard has full power to block Safe transaction execution,\\n     *        a broken guard can cause a denial of service for the Safe. Make sure to carefully\\n     *        audit the guard code and design recovery mechanisms.\\n     * @notice Set Transaction Guard `guard` for the Safe. Make sure you trust the guard.\\n     * @param guard The address of the guard to be used or the 0 address to disable the guard\\n     */\\n    function setGuard(address guard) external;\\n}\\n\",\"keccak256\":\"0xca10c744bd853f69f3c63282a2560462085a253c6034f108f97a575ec2fd61ab\",\"license\":\"LGPL-3.0-only\"},\"@safe-global/safe-smart-account/contracts/interfaces/IModuleManager.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\nimport {Enum} from \\\"../libraries/Enum.sol\\\";\\n\\n/**\\n * @title IModuleManager - An interface of contract managing Safe modules\\n * @notice Modules are extensions with unlimited access to a Safe that can be added to a Safe by its owners.\\n           \\u26a0\\ufe0f WARNING: Modules are a security risk since they can execute arbitrary transactions, \\n           so only trusted and audited modules should be added to a Safe. A malicious module can\\n           completely takeover a Safe.\\n * @author @safe-global/safe-protocol\\n */\\ninterface IModuleManager {\\n    event EnabledModule(address indexed module);\\n    event DisabledModule(address indexed module);\\n    event ExecutionFromModuleSuccess(address indexed module);\\n    event ExecutionFromModuleFailure(address indexed module);\\n    event ChangedModuleGuard(address indexed moduleGuard);\\n\\n    /**\\n     * @notice Enables the module `module` for the Safe.\\n     * @dev This can only be done via a Safe transaction.\\n     * @param module Module to be whitelisted.\\n     */\\n    function enableModule(address module) external;\\n\\n    /**\\n     * @notice Disables the module `module` for the Safe.\\n     * @dev This can only be done via a Safe transaction.\\n     * @param prevModule Previous module in the modules linked list.\\n     * @param module Module to be removed.\\n     */\\n    function disableModule(address prevModule, address module) external;\\n\\n    /**\\n     * @notice Execute `operation` (0: Call, 1: DelegateCall) to `to` with `value` (Native Token)\\n     * @param to Destination address of module transaction.\\n     * @param value Ether value of module transaction.\\n     * @param data Data payload of module transaction.\\n     * @param operation Operation type of module transaction.\\n     * @return success Boolean flag indicating if the call succeeded.\\n     */\\n    function execTransactionFromModule(\\n        address to,\\n        uint256 value,\\n        bytes memory data,\\n        Enum.Operation operation\\n    ) external returns (bool success);\\n\\n    /**\\n     * @notice Execute `operation` (0: Call, 1: DelegateCall) to `to` with `value` (Native Token) and return data\\n     * @param to Destination address of module transaction.\\n     * @param value Ether value of module transaction.\\n     * @param data Data payload of module transaction.\\n     * @param operation Operation type of module transaction.\\n     * @return success Boolean flag indicating if the call succeeded.\\n     * @return returnData Data returned by the call.\\n     */\\n    function execTransactionFromModuleReturnData(\\n        address to,\\n        uint256 value,\\n        bytes memory data,\\n        Enum.Operation operation\\n    ) external returns (bool success, bytes memory returnData);\\n\\n    /**\\n     * @notice Returns if an module is enabled\\n     * @return True if the module is enabled\\n     */\\n    function isModuleEnabled(address module) external view returns (bool);\\n\\n    /**\\n     * @notice Returns an array of modules.\\n     *         If all entries fit into a single page, the next pointer will be 0x1.\\n     *         If another page is present, next will be the last element of the returned array.\\n     * @param start Start of the page. Has to be a module or start pointer (0x1 address)\\n     * @param pageSize Maximum number of modules that should be returned. Has to be > 0\\n     * @return array Array of modules.\\n     * @return next Start of the next page.\\n     */\\n    function getModulesPaginated(address start, uint256 pageSize) external view returns (address[] memory array, address next);\\n\\n    /**\\n     * @dev Set a module guard that checks transactions initiated by the module before execution\\n     *      This can only be done via a Safe transaction.\\n     *      \\u26a0\\ufe0f IMPORTANT: Since a module guard has full power to block Safe transaction execution initiatied via a module,\\n     *        a broken module guard can cause a denial of service for the Safe modules. Make sure to carefully\\n     *        audit the module guard code and design recovery mechanisms.\\n     * @notice Set Module Guard `moduleGuard` for the Safe. Make sure you trust the module guard.\\n     * @param moduleGuard The address of the module guard to be used or the zero address to disable the module guard.\\n     */\\n    function setModuleGuard(address moduleGuard) external;\\n}\\n\",\"keccak256\":\"0xf54fec9a87bbbb9585dd6223f75a178992e5de6ba8670aeb2197d0ba8b538251\",\"license\":\"LGPL-3.0-only\"},\"@safe-global/safe-smart-account/contracts/interfaces/IOwnerManager.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\n\\n/**\\n * @title IOwnerManager - Interface for contract which manages Safe owners and a threshold to authorize transactions.\\n * @author @safe-global/safe-protocol\\n */\\ninterface IOwnerManager {\\n    event AddedOwner(address indexed owner);\\n    event RemovedOwner(address indexed owner);\\n    event ChangedThreshold(uint256 threshold);\\n\\n    /**\\n     * @notice Adds the owner `owner` to the Safe and updates the threshold to `_threshold`.\\n     * @dev This can only be done via a Safe transaction.\\n     * @param owner New owner address.\\n     * @param _threshold New threshold.\\n     */\\n    function addOwnerWithThreshold(address owner, uint256 _threshold) external;\\n\\n    /**\\n     * @notice Removes the owner `owner` from the Safe and updates the threshold to `_threshold`.\\n     * @dev This can only be done via a Safe transaction.\\n     * @param prevOwner Owner that pointed to the owner to be removed in the linked list\\n     * @param owner Owner address to be removed.\\n     * @param _threshold New threshold.\\n     */\\n    function removeOwner(address prevOwner, address owner, uint256 _threshold) external;\\n\\n    /**\\n     * @notice Replaces the owner `oldOwner` in the Safe with `newOwner`.\\n     * @dev This can only be done via a Safe transaction.\\n     * @param prevOwner Owner that pointed to the owner to be replaced in the linked list\\n     * @param oldOwner Owner address to be replaced.\\n     * @param newOwner New owner address.\\n     */\\n    function swapOwner(address prevOwner, address oldOwner, address newOwner) external;\\n\\n    /**\\n     * @notice Changes the threshold of the Safe to `_threshold`.\\n     * @dev This can only be done via a Safe transaction.\\n     * @param _threshold New threshold.\\n     */\\n    function changeThreshold(uint256 _threshold) external;\\n\\n    /**\\n     * @notice Returns the number of required confirmations for a Safe transaction aka the threshold.\\n     * @return Threshold number.\\n     */\\n    function getThreshold() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns if `owner` is an owner of the Safe.\\n     * @return Boolean if owner is an owner of the Safe.\\n     */\\n    function isOwner(address owner) external view returns (bool);\\n\\n    /**\\n     * @notice Returns a list of Safe owners.\\n     * @return Array of Safe owners.\\n     */\\n    function getOwners() external view returns (address[] memory);\\n}\\n\",\"keccak256\":\"0x001491dd52e268b2bb1a8fef7a77150da827f298ce858e8ed47aa257c55d528b\",\"license\":\"LGPL-3.0-only\"},\"@safe-global/safe-smart-account/contracts/interfaces/ISafe.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\n\\nimport {Enum} from \\\"./../libraries/Enum.sol\\\";\\nimport {IFallbackManager} from \\\"./IFallbackManager.sol\\\";\\nimport {IGuardManager} from \\\"./IGuardManager.sol\\\";\\nimport {IModuleManager} from \\\"./IModuleManager.sol\\\";\\nimport {IOwnerManager} from \\\"./IOwnerManager.sol\\\";\\n\\n/**\\n * @title ISafe - A multisignature wallet interface with support for confirmations using signed messages based on EIP-712.\\n * @author @safe-global/safe-protocol\\n */\\ninterface ISafe is IModuleManager, IGuardManager, IOwnerManager, IFallbackManager {\\n    event SafeSetup(address indexed initiator, address[] owners, uint256 threshold, address initializer, address fallbackHandler);\\n    event ApproveHash(bytes32 indexed approvedHash, address indexed owner);\\n    event SignMsg(bytes32 indexed msgHash);\\n    event ExecutionFailure(bytes32 indexed txHash, uint256 payment);\\n    event ExecutionSuccess(bytes32 indexed txHash, uint256 payment);\\n\\n    /**\\n     * @notice Sets an initial storage of the Safe contract.\\n     * @dev This method can only be called once.\\n     *      If a proxy was created without setting up, anyone can call setup and claim the proxy.\\n     * @param _owners List of Safe owners.\\n     * @param _threshold Number of required confirmations for a Safe transaction.\\n     * @param to Contract address for optional delegate call.\\n     * @param data Data payload for optional delegate call.\\n     * @param fallbackHandler Handler for fallback calls to this contract\\n     * @param paymentToken Token that should be used for the payment (0 is ETH)\\n     * @param payment Value that should be paid\\n     * @param paymentReceiver Address that should receive the payment (or 0 if tx.origin)\\n     */\\n    function setup(\\n        address[] calldata _owners,\\n        uint256 _threshold,\\n        address to,\\n        bytes calldata data,\\n        address fallbackHandler,\\n        address paymentToken,\\n        uint256 payment,\\n        address payable paymentReceiver\\n    ) external;\\n\\n    /** @notice Executes a `operation` {0: Call, 1: DelegateCall}} transaction to `to` with `value` (Native Currency)\\n     *          and pays `gasPrice` * `gasLimit` in `gasToken` token to `refundReceiver`.\\n     * @dev The fees are always transferred, even if the user transaction fails.\\n     *      This method doesn't perform any sanity check of the transaction, such as:\\n     *      - if the contract at `to` address has code or not\\n     *      - if the `gasToken` is a contract or not\\n     *      It is the responsibility of the caller to perform such checks.\\n     * @param to Destination address of Safe transaction.\\n     * @param value Ether value of Safe transaction.\\n     * @param data Data payload of Safe transaction.\\n     * @param operation Operation type of Safe transaction.\\n     * @param safeTxGas Gas that should be used for the Safe transaction.\\n     * @param baseGas Gas costs that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\\n     * @param gasPrice Gas price that should be used for the payment calculation.\\n     * @param gasToken Token address (or 0 if ETH) that is used for the payment.\\n     * @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\\n     * @param signatures Signature data that should be verified.\\n     *                   Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.\\n     * @return success Boolean indicating transaction's success.\\n     */\\n    function execTransaction(\\n        address to,\\n        uint256 value,\\n        bytes calldata data,\\n        Enum.Operation operation,\\n        uint256 safeTxGas,\\n        uint256 baseGas,\\n        uint256 gasPrice,\\n        address gasToken,\\n        address payable refundReceiver,\\n        bytes memory signatures\\n    ) external payable returns (bool success);\\n\\n    /**\\n     * @notice Checks whether the signature provided is valid for the provided data and hash. Reverts otherwise.\\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\\n     * @param signatures Signature data that should be verified.\\n     *                   Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.\\n     */\\n    function checkSignatures(bytes32 dataHash, bytes memory signatures) external view;\\n\\n    /**\\n     * @notice Checks whether the signature provided is valid for the provided data and hash. Reverts otherwise.\\n     * @dev Since the EIP-1271 does an external call, be mindful of reentrancy attacks.\\n     * @param executor Address that executing the transaction.\\n     *        \\u26a0\\ufe0f\\u26a0\\ufe0f\\u26a0\\ufe0f Make sure that the executor address is a legitmate executor.\\n     *        Incorrectly passed the executor might reduce the threshold by 1 signature. \\u26a0\\ufe0f\\u26a0\\ufe0f\\u26a0\\ufe0f\\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\\n     * @param signatures Signature data that should be verified.\\n     *                   Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.\\n     * @param requiredSignatures Amount of required valid signatures.\\n     */\\n    function checkNSignatures(address executor, bytes32 dataHash, bytes memory signatures, uint256 requiredSignatures) external view;\\n\\n    /**\\n     * @notice Marks hash `hashToApprove` as approved.\\n     * @dev This can be used with a pre-approved hash transaction signature.\\n     *      IMPORTANT: The approved hash stays approved forever. There's no revocation mechanism, so it behaves similarly to ECDSA signatures\\n     * @param hashToApprove The hash to mark as approved for signatures that are verified by this contract.\\n     */\\n    function approveHash(bytes32 hashToApprove) external;\\n\\n    /**\\n     * @dev Returns the domain separator for this contract, as defined in the EIP-712 standard.\\n     * @return bytes32 The domain separator hash.\\n     */\\n    function domainSeparator() external view returns (bytes32);\\n\\n    /**\\n     * @notice Returns transaction hash to be signed by owners.\\n     * @param to Destination address.\\n     * @param value Ether value.\\n     * @param data Data payload.\\n     * @param operation Operation type.\\n     * @param safeTxGas Gas that should be used for the safe transaction.\\n     * @param baseGas Gas costs for data used to trigger the safe transaction.\\n     * @param gasPrice Maximum gas price that should be used for this transaction.\\n     * @param gasToken Token address (or 0 if ETH) that is used for the payment.\\n     * @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\\n     * @param _nonce Transaction nonce.\\n     * @return Transaction hash.\\n     */\\n    function getTransactionHash(\\n        address to,\\n        uint256 value,\\n        bytes calldata data,\\n        Enum.Operation operation,\\n        uint256 safeTxGas,\\n        uint256 baseGas,\\n        uint256 gasPrice,\\n        address gasToken,\\n        address refundReceiver,\\n        uint256 _nonce\\n    ) external view returns (bytes32);\\n\\n    /**\\n     * External getter function for state variables.\\n     */\\n\\n    /**\\n     * @notice Returns the version of the Safe contract.\\n     * @return Version string.\\n     */\\n    // solhint-disable-next-line\\n    function VERSION() external view returns (string memory);\\n\\n    /**\\n     * @notice Returns the nonce of the Safe contract.\\n     * @return Nonce.\\n     */\\n    function nonce() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns a uint if the messageHash is signed by the owner.\\n     * @param messageHash Hash of message that should be checked.\\n     * @return Number denoting if an owner signed the hash.\\n     */\\n    function signedMessages(bytes32 messageHash) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns a uint if the messageHash is approved by the owner.\\n     * @param owner Owner address that should be checked.\\n     * @param messageHash Hash of message that should be checked.\\n     * @return Number denoting if an owner approved the hash.\\n     */\\n    function approvedHashes(address owner, bytes32 messageHash) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xfa79ca5f90a5b269b4f9c519df65fdb2f5b7e9f20d3c7bd95edc530e4f006773\",\"license\":\"LGPL-3.0-only\"},\"@safe-global/safe-smart-account/contracts/libraries/Enum.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\n\\n/**\\n * @title Enum - Collection of enums used in Safe Smart Account contracts.\\n * @author @safe-global/safe-protocol\\n */\\nlibrary Enum {\\n    enum Operation {\\n        Call,\\n        DelegateCall\\n    }\\n}\\n\",\"keccak256\":\"0x443e310b464e7580bb2fd50e3a2d323efbbfa53e2433832eec509e127ecd6261\",\"license\":\"LGPL-3.0-only\"},\"contracts/SafeModuleSetup.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.8.27;\\n\\nimport {ISafe} from \\\"@safe-global/safe-smart-account/contracts/interfaces/ISafe.sol\\\";\\n\\n/**\\n * @title SafeModuleSetup - A utility contract for setting up a Safe with modules.\\n * @dev The Safe `setup` function accepts `to` and `data` parameters for a delegate call during initialization. This\\n *      contract can be specified as the `to` with `data` ABI encoding the `enableModules` call so that a Safe is\\n *      created with the specified modules. In particular, this allows a ERC-4337 compatible Safe to be created as part\\n *      of a ERC-4337 user operation with the `Safe4337Module` enabled right away.\\n * @custom:security-contact bounty@safe.global\\n */\\ncontract SafeModuleSetup {\\n    /**\\n     * @notice Enable the specified Safe modules.\\n     * @dev This call will only work if used from a Safe via delegatecall. It is intended to be used as part of the\\n     *      Safe `setup`, allowing Safes to be created with an initial set of enabled modules.\\n     * @param modules The modules to enable.\\n     */\\n    function enableModules(address[] calldata modules) external {\\n        for (uint256 i = 0; i < modules.length; i++) {\\n            ISafe(address(this)).enableModule(modules[i]);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8ccc63e81a19586b73e530db50139356ced5f9e243f186df2fece8325345ce2f\",\"license\":\"LGPL-3.0-only\"}},\"version\":1}",
  "bytecode": "0x6080604052348015600f57600080fd5b506102258061001f6000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c80638d0dc49f14610030575b600080fd5b61004361003e36600461010c565b610045565b005b60005b81811015610107573063610b592584848481811061006857610068610183565b905060200201602081019061007d91906101b2565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b16815273ffffffffffffffffffffffffffffffffffffffff9091166004820152602401600060405180830381600087803b1580156100e357600080fd5b505af11580156100f7573d6000803e3d6000fd5b5050600190920191506100489050565b505050565b6000806020838503121561011f57600080fd5b823567ffffffffffffffff81111561013657600080fd5b8301601f8101851361014757600080fd5b803567ffffffffffffffff81111561015e57600080fd5b8560208260051b840101111561017357600080fd5b6020919091019590945092505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6000602082840312156101c457600080fd5b813573ffffffffffffffffffffffffffffffffffffffff811681146101e857600080fd5b939250505056fea26469706673582212203c3dfbce7bbcf2ef723c1ea0a752dddf1de9235eacad57c9b9e98bce6902c29364736f6c634300081b0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c80638d0dc49f14610030575b600080fd5b61004361003e36600461010c565b610045565b005b60005b81811015610107573063610b592584848481811061006857610068610183565b905060200201602081019061007d91906101b2565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b16815273ffffffffffffffffffffffffffffffffffffffff9091166004820152602401600060405180830381600087803b1580156100e357600080fd5b505af11580156100f7573d6000803e3d6000fd5b5050600190920191506100489050565b505050565b6000806020838503121561011f57600080fd5b823567ffffffffffffffff81111561013657600080fd5b8301601f8101851361014757600080fd5b803567ffffffffffffffff81111561015e57600080fd5b8560208260051b840101111561017357600080fd5b6020919091019590945092505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6000602082840312156101c457600080fd5b813573ffffffffffffffffffffffffffffffffffffffff811681146101e857600080fd5b939250505056fea26469706673582212203c3dfbce7bbcf2ef723c1ea0a752dddf1de9235eacad57c9b9e98bce6902c29364736f6c634300081b0033",
  "devdoc": {
    "custom:security-contact": "bounty@safe.global",
    "details": "The Safe `setup` function accepts `to` and `data` parameters for a delegate call during initialization. This      contract can be specified as the `to` with `data` ABI encoding the `enableModules` call so that a Safe is      created with the specified modules. In particular, this allows a ERC-4337 compatible Safe to be created as part      of a ERC-4337 user operation with the `Safe4337Module` enabled right away.",
    "kind": "dev",
    "methods": {
      "enableModules(address[])": {
        "details": "This call will only work if used from a Safe via delegatecall. It is intended to be used as part of the      Safe `setup`, allowing Safes to be created with an initial set of enabled modules.",
        "params": {
          "modules": "The modules to enable."
        }
      }
    },
    "title": "SafeModuleSetup - A utility contract for setting up a Safe with modules.",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "enableModules(address[])": {
        "notice": "Enable the specified Safe modules."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}